(verification-unit "QSORT"
		   :sources (((:lang :clir)
			      (:module :self)))
		   :uses (:ir :ir.int :ir.array :lemmas.arrays)
		   :documentation "This is the quicksort function on the CLIR.")

(define arrCopy
    ((v (array int)))
    ((vres (array int)))
  (declare (precd true)
           (postcd (and (@ = (@ length v)
                             (@ length vres))
                        (forall ((i int))
                                 (-> (and (@ <= 0 i)
                                          (@ < i length))
                                     (@ = (@ get result i)
                                          (@ get v i)))))))
  (external (:type why3)
   "let v1 = make (length v) 1 in
        begin   
                for i=0 to (length v)-1 do      
                    invariant {forall j. 0<=j<i -> v1[j] = v[j]}
                    v1[i] <- v[i]
                done;
                v1
        end"))

(define swap
    ((v (array int))
     (i int)
     (j int))
    ((vres (array int)))
  (declare (precd (and (@ <= 0 i)
                       (@ < i (@ length v))
                       (@ <= 0 j)
                       (@ < j (@ length v))))
           (postcd (@ exchange v result i j)))

    (external (:type why3)
     "let v1 = arrCopy v in     
      v1[i] <- v[j];
      v1[j] <- v[i];
      v1"))


(define partition
    ((v (array int)) (l int) (r int))
    ((vres (array int)) (split int))
  (declare (assertion
            (precd (and
                    (@ <= (the int 0) l r)
                    (@ < r (@ length v))))
            (postcd (and (@ permut_sub v vres l (@ + (the int 1) r))
                         (@ <= l split r)
                         (forall ((k1 int))
                                 (-> (@ <= (the int 0) l)
                                     (@ = (@ get v k1)
                                          (@ get vres k1))))
                         (forall ((k2 int))
                                 (-> (@ < r (@ length vres))
                                     (@ = (@ get v k2)
                                          (@ get vres k2))))
                         (forall ((j1 int))
                                 (-> (and (@ <= l j1)
                                          (@ < j1 split))
                                     (@ <= (@ get vres j1)
                                           (@ get vres split))))
                         (forall ((j2 int))
                                 (-> (and (@ < split j2)
                                          (@ <= j2 r))
                                     (@ >= (@ get vres j2)
                                           (@ get vres split))))))))

  (letfun
      ((theloop ((v int) (a (array int)) (l int) (r int) (i int) (m int)) ((ares (array int)) (ix int))
         (declare (assertion)) ;; Needs invariant.
         (let ((r1 int)) (@ - r (the int 1))
              (let ((b bool)) (@ <= i r1)
                   (case b
                     ((the bool false) (tuple a m))
                     ((the bool true)
                      (let ((a1 (array int)) (m1 int)) (@ k a i v m)
                           (let ((i1 int)) (@ + i (the int 1))
                                (@ theloop v a1 l r i1 m1)))))))
         (let ((aj int)) (@ get a j)
              (let ((b bool)) (@ <= aj pivot)
                   (case b
                     ((the bool false) i)
                     ((the bool true) (@ + (the int 1) i))))))

       (k ((a (array int)) (i int) (v int) (m int)) ((ares (array int)) (ix int))
         (let ((ai int)) (@ get a i)
              (let ((b bool)) (@ < ai v)
                   (case b
                     ((the bool false) (tuple a m))
                     ((the bool true)
                      (let ((m1 int)) (@ + m (the int 1))
                           (let ((ares (array int))) (@ swap a i m1)
                                (tuple ares m1)))))))))
    (let ((l1 int)) (@ + l (the int 1))
         (let ((b bool)) (@ < l1 r)
              (case b
                ((the bool false) v)
                ((the bool true)
                 (let ((vl int)) (@ get v l)
                      (let ((l1 int)) (@ + l (the int 1))
                           (let ((vx (array int)) (m1 int)) (@ theloop vl v l r l1 l)
                                (@ swap vx l m1))))))))))


(define quicksort ((v (array int)) (n int)) ((vres (array int)))
  (declare
   (assertion
    (precd (and (@ < (the int 0) (@ length v))
                (@ = n (@ length v))))
    (postcd (and (@ sorted vres)
		 (@ permut_all v vres)))))
  (letfun
      ((qsort ((v (array int)) (i int) (j int)) ((vsort (array int)))
	 (declare
	  (assertion
	   (precd (and (@ <= (the int 0) i j)
                       (@ < j (@ length v))))
	   (postcd (and (@ sorted_sub vsort i (@ + (the int 1) j))
			(@ permut_sub v vsort i (@ + (the int 1) j))))))
	 (let ((b bool)) (@ < i j)
           (case b
             ((the bool true) (@ f1 v i j))
             ((the bool false) v))))
       (f1 ((v (array int)) (i int) (j int)) ((result (array int)))
	 (let ((v1 (array int)) (p int)) (@ partition v i j)
           (let ((p1 int)) (@ - p (the int 1))
             (let ((v2 (array int))) (@ qsort v1 i p1)
               (let ((p2 int)) (@ + p (the int 1))
                 (@ qsort v2 p2 j)))))))
    (let ((n1 int)) (@ - n (the int 1))
      (@ qsort v (the int 0) n1))))


;; Local Variables:
;; mode: common-lisp
;; coding: utf-8
;; slime-buffer-package: "ir.vc.core"
;; End:
