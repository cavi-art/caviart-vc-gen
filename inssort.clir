;; These instructions makes the code available at any time. They can
;; be removed, but then a Common-Lisp runtime will not know how to
;; parse the file.
;; (cl:eval-when (:compile-toplevel :load-toplevel :execute)
;;   (load "init.lisp"))
;; End of bogus instruction

(verification-unit "inssort"
		   :sources (((:lang :erlang)
			      (:module "/inssort.erl")))
		   :uses (:ir)
		   :documentation "This is the implementation of a verified insertion sort in CLIR")


;; Test function (outside core for the moment)
(define create-list-and-heap ()
  (let (l cl:list) '((0 . 1)
		     (1 . 2)
		     (2 . 234)
		     (3 . 23)
		     (4 . 56)
		     (5 . 41))
    (cl:multiple-value-bind (v h) (newptr-in-heap (new-heap) l)
      (inssort v h))))


(define inssort ((V (loc (array int))) (H heap)) (inssort heap)
  (declare (assertion
	    (precd true)
	    (postcd (:forall (E (array int))
			     (-> (= E (deref inssort V))
				 sorted E)))))
  (letfun
      ((f1 ((V (loc (array int))) (H heap)) (_ heap)
	 (let (I int) (the int 0)
	   (@ f2 (var V) (var I) (var H))))
			
       (f2 ((V (loc (array int))) (I int) (H heap)) (f2 heap)
	 (declare
	  (assertion
	   (precd (:forall ((E (array int)))
			   (-> (= (deref H V) E)
			       (and (sorted_sub E 0 I)
				    (<= 0 I)))))
	   (postcd (:forall ((E (array int)))
			    (-> (= (deref f2 V) E)
				(sorted E))))))
	 (let (X1 int) (@ len-array-heap H V)
	   (let (B bool) (@ < (var I) (var X1))
	     (case (var B)
	       ((true) (@ f3 (var V) (var I) (var H)))
	       ((false) (var H))))))
			
       (f3 ((V (loc (array int))) (I int) (H heap)) (_ heap)
	 (let (J int) (@ - (var I) (the int 1))
	   (@ f4 (var V) (var I) (var J) (var H))))
			
       (f4 ((V (loc (array int))) (I int) (J int) (H heap)) (f4 heap)
	 (declare
	  (assertion
	   (precd (:forall ((E (array int)))
			   (-> (= (deref H V) E)
			       (and (sorted_sub E 0 (+ J 1))
				    (sorted_sub E (+ J 1) (+ I 1))
				    (<= -1 J)
				    (<= (sel-array E (- J 1))
					(sel-array E (+ J 1)))))))))
	 (let (B1 bool) (@ >= (var J) (the int 0))
	   (case (var B1)
	     ((false) (@ f6 (var V) (var I) (var H)))
	     ((true) (let (VJ int) (@ sel-array-heap (var H) (var V) (var J))
		       (let (J1 int) (@ + (var J) (the int 1))
			 (let (VJ1 int) (@ sel-array-heap (var H) (var V) (var J1))
			   (let (B2 bool) (@ > (var VJ) (var VJ1))
			     (case (var B2)
			       ((false) (@ f6 (var V) (var I) (var H)))
			       ((true) (@ f5 (var V) (var I) (var J) (var H))))))))))))
			
       (f5 ((V (loc (array int))) (I int) (J int) (H heap)) (_ heap)
	 (let (E int) (@ sel-array-heap (var H) (var V) (var J))
	   (let (J1 int) (@ + (var J) (the int 1))
	     (let (E2 int) (@ sel-array-heap (var H) (var V) (var J1))
	       (let (H1 heap) (@ mod-array-heap (var H) (var V) (var J) (var E2))
		 (let (H2 heap) (@ mod-array-heap (var H1) (var V) (var J1) (var E))
		   (let (J2 int) (@ - (var J) (the int 1))
		     (@ f4 (var V) (var I) (var J2) (var H2)))))))))
			
       ;; This would just show the alternative, if it existed
       ;; let* can allow for multiple bindings at once,
       ;; flattening the otherwise nested structure.
       ;; The binding is sequential.
       ;; (f5-prime ((V (loc (array int))) (I int) (J int) (H heap))
       ;;   (let* ((E (@ sel-array-heap H V J))
       ;; 	 (J1 (@ + J (the int 1)))
       ;; 	 (E2 (@ sel-array-heap H V J1))
       ;; 	 (H1 (@ mod-array-heap H V J E2))
       ;; 	 (H2 (@ mod-array-heap H1 V J1 E))
       ;; 	 (J2 (@ - J (the int 1))))
       ;;     (@ f4 V I J2 H2)))
			
       (f6 ((V (loc (array int))) (I int) (H heap)) (_ heap)
	 (let (I1 int) (@ + (var I) (the int 1))
	   (@ f2 (var V) (var I1) (var H)))))
    (@ f1 (var V) (var H))))


;; Local Variables:
;; mode: common-lisp
;; coding: utf-8
;; End:
