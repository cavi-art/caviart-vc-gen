;; These instructions makes the code available at any time. They can
;; be removed, but then a Common-Lisp runtime will not know how to
;; parse the file.
(cl:eval-when (:compile-toplevel :load-toplevel :execute)
  (load "init.lisp"))
;; End of bogus instruction

(package :inssort
	 :uses (:ir)
	 :documentation "This is the implementation of a verified insertion sort in CLIR")


;; Test function (outside core for the moment)
(define create-list-and-heap ()
  (let l '((0 . 1)
	   (1 . 2)
	   (2 . 234)
	   (3 . 23)
	   (4 . 56)
	   (5 . 41))
       (cl:multiple-value-bind (v h) (newptr-in-heap (new-heap) l)
	 (inssort v h))))


(define f1 (V H)
  (declare (type heap H)
	   (type (loc (array int)) V))
  (let I (the int 0)
    (f2 V I H)))

(define f2 (V I H)
  (declare
   (assertion
    (precd (:forall ((E (array fixnum)))
		    (-> (= (deref H V) E)
			(and (sorted_sub E 0 I)
			     (<= 0 I)))))
    (postcd (:forall ((E (array fixnum)))
		     (-> (= (deref H V) E)
			 (sorted E)))))
   (type (loc (array fixnum)) V)
   (type heap H)
   (type fixnum I))

  (let X1 (len-array-heap H V)
    (let B (< I X1)
      (case B
	((t) (f3 V I H))
	((nil) H)))))


(define f3 (V I H)
  (declare (type heap H)
	   (type (loc (array fixnum)) V)
	   (type fixnum I))
  (let J (- I (the fixnum 1))
    (f4 V I J H)))


(define f4 (V I J H)
  (declare
   (assertion
    (precd (:forall ((E (array fixnum)))
		    (-> (= (deref H V) E)
			(and (sorted_sub E 0 (+ J 1))
			     (sorted_sub E (+ J 1) (+ I 1))
			     (<= -1 J)
			     (<= (sel-array E (- J 1))
				 (sel-array E (+ J 1))))))))
   (type heap H)
   (type (loc (array fixnum)) V)
   (type fixnum I J))

  (let B1 (>= J (the fixnum 0))
    (case B1
      ((nil) (f6 V I H))
      ((t) (let VJ (sel-array-heap H V J)
	     (let J1 (+ J (the fixnum 1))
	       (let VJ1 (sel-array-heap H V J1)
		 (let B2 (> VJ VJ1)
		   (case B2
		     ((nil) (f6 V I H))
		     ((t) (f5 V I J H)))))))))))


(define f5 (V I J H)
  (declare (type heap H)
	   (type (loc (array fixnum)) V)
	   (type fixnum I J))
  (let E (sel-array-heap H V J)
    (let J1  (+ J (the fixnum 1))
      (let E2 (sel-array-heap H V J1)
	(let H1 (mod-array-heap H V J E2)
	  (let H2 (mod-array-heap H1 V J1 E)
	    (let J2 (- J (the fixnum 1))
	      (f4 V I J2 H2))))))))


;; This would just show the alternative, if it existed
;; let* can allow for multiple bindings at once,
;; flattening the otherwise nested structure.
;; The binding is sequential.
(define f5-prime (V I J H)
  (declare (type heap H)
	   (type (loc (array fixnum)) V)
	   (type fixnum I J))
  (let* ((E (sel-array-heap H V J))
	 (J1  (+ J (the fixnum 1)))
	 (E2 (sel-array-heap H V J1))
	 (H1 (mod-array-heap H V J E2))
	 (H2 (mod-array-heap H1 V J1 E))
	 (J2 (- J (the fixnum 1))))
    (f4 V I J2 H2)))



(define f6 (V I H)
  (declare (type heap H)
	   (type (loc (array fixnum)) V)
	   (type fixnum I))
  (let I1 (+ I (the fixnum 1))
    (f2 V I1 H)))


(define inssort (V H)
  (f1 V H))



;; Local Variables:
;; mode: common-lisp
;; coding: utf-8
;; End:
